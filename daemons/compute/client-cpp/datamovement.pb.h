// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: datamovement.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_datamovement_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_datamovement_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_datamovement_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_datamovement_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_datamovement_2eproto;
namespace datamovement {
class DataMovementCreateRequest;
struct DataMovementCreateRequestDefaultTypeInternal;
extern DataMovementCreateRequestDefaultTypeInternal _DataMovementCreateRequest_default_instance_;
class DataMovementCreateResponse;
struct DataMovementCreateResponseDefaultTypeInternal;
extern DataMovementCreateResponseDefaultTypeInternal _DataMovementCreateResponse_default_instance_;
class DataMovementDeleteRequest;
struct DataMovementDeleteRequestDefaultTypeInternal;
extern DataMovementDeleteRequestDefaultTypeInternal _DataMovementDeleteRequest_default_instance_;
class DataMovementDeleteResponse;
struct DataMovementDeleteResponseDefaultTypeInternal;
extern DataMovementDeleteResponseDefaultTypeInternal _DataMovementDeleteResponse_default_instance_;
class DataMovementListRequest;
struct DataMovementListRequestDefaultTypeInternal;
extern DataMovementListRequestDefaultTypeInternal _DataMovementListRequest_default_instance_;
class DataMovementListResponse;
struct DataMovementListResponseDefaultTypeInternal;
extern DataMovementListResponseDefaultTypeInternal _DataMovementListResponse_default_instance_;
class DataMovementStatusRequest;
struct DataMovementStatusRequestDefaultTypeInternal;
extern DataMovementStatusRequestDefaultTypeInternal _DataMovementStatusRequest_default_instance_;
class DataMovementStatusResponse;
struct DataMovementStatusResponseDefaultTypeInternal;
extern DataMovementStatusResponseDefaultTypeInternal _DataMovementStatusResponse_default_instance_;
}  // namespace datamovement
PROTOBUF_NAMESPACE_OPEN
template<> ::datamovement::DataMovementCreateRequest* Arena::CreateMaybeMessage<::datamovement::DataMovementCreateRequest>(Arena*);
template<> ::datamovement::DataMovementCreateResponse* Arena::CreateMaybeMessage<::datamovement::DataMovementCreateResponse>(Arena*);
template<> ::datamovement::DataMovementDeleteRequest* Arena::CreateMaybeMessage<::datamovement::DataMovementDeleteRequest>(Arena*);
template<> ::datamovement::DataMovementDeleteResponse* Arena::CreateMaybeMessage<::datamovement::DataMovementDeleteResponse>(Arena*);
template<> ::datamovement::DataMovementListRequest* Arena::CreateMaybeMessage<::datamovement::DataMovementListRequest>(Arena*);
template<> ::datamovement::DataMovementListResponse* Arena::CreateMaybeMessage<::datamovement::DataMovementListResponse>(Arena*);
template<> ::datamovement::DataMovementStatusRequest* Arena::CreateMaybeMessage<::datamovement::DataMovementStatusRequest>(Arena*);
template<> ::datamovement::DataMovementStatusResponse* Arena::CreateMaybeMessage<::datamovement::DataMovementStatusResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace datamovement {

enum DataMovementCreateResponse_Status : int {
  DataMovementCreateResponse_Status_CREATED = 0,
  DataMovementCreateResponse_Status_FAILED = 1,
  DataMovementCreateResponse_Status_DataMovementCreateResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataMovementCreateResponse_Status_DataMovementCreateResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataMovementCreateResponse_Status_IsValid(int value);
constexpr DataMovementCreateResponse_Status DataMovementCreateResponse_Status_Status_MIN = DataMovementCreateResponse_Status_CREATED;
constexpr DataMovementCreateResponse_Status DataMovementCreateResponse_Status_Status_MAX = DataMovementCreateResponse_Status_FAILED;
constexpr int DataMovementCreateResponse_Status_Status_ARRAYSIZE = DataMovementCreateResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataMovementCreateResponse_Status_descriptor();
template<typename T>
inline const std::string& DataMovementCreateResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMovementCreateResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMovementCreateResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataMovementCreateResponse_Status_descriptor(), enum_t_value);
}
inline bool DataMovementCreateResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMovementCreateResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataMovementCreateResponse_Status>(
    DataMovementCreateResponse_Status_descriptor(), name, value);
}
enum DataMovementStatusResponse_State : int {
  DataMovementStatusResponse_State_PENDING = 0,
  DataMovementStatusResponse_State_STARTING = 1,
  DataMovementStatusResponse_State_RUNNING = 2,
  DataMovementStatusResponse_State_COMPLETED = 3,
  DataMovementStatusResponse_State_UNKNOWN_STATE = 4,
  DataMovementStatusResponse_State_DataMovementStatusResponse_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataMovementStatusResponse_State_DataMovementStatusResponse_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataMovementStatusResponse_State_IsValid(int value);
constexpr DataMovementStatusResponse_State DataMovementStatusResponse_State_State_MIN = DataMovementStatusResponse_State_PENDING;
constexpr DataMovementStatusResponse_State DataMovementStatusResponse_State_State_MAX = DataMovementStatusResponse_State_UNKNOWN_STATE;
constexpr int DataMovementStatusResponse_State_State_ARRAYSIZE = DataMovementStatusResponse_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataMovementStatusResponse_State_descriptor();
template<typename T>
inline const std::string& DataMovementStatusResponse_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMovementStatusResponse_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMovementStatusResponse_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataMovementStatusResponse_State_descriptor(), enum_t_value);
}
inline bool DataMovementStatusResponse_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMovementStatusResponse_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataMovementStatusResponse_State>(
    DataMovementStatusResponse_State_descriptor(), name, value);
}
enum DataMovementStatusResponse_Status : int {
  DataMovementStatusResponse_Status_INVALID = 0,
  DataMovementStatusResponse_Status_NOT_FOUND = 1,
  DataMovementStatusResponse_Status_SUCCESS = 2,
  DataMovementStatusResponse_Status_FAILED = 3,
  DataMovementStatusResponse_Status_UNKNOWN_STATUS = 4,
  DataMovementStatusResponse_Status_DataMovementStatusResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataMovementStatusResponse_Status_DataMovementStatusResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataMovementStatusResponse_Status_IsValid(int value);
constexpr DataMovementStatusResponse_Status DataMovementStatusResponse_Status_Status_MIN = DataMovementStatusResponse_Status_INVALID;
constexpr DataMovementStatusResponse_Status DataMovementStatusResponse_Status_Status_MAX = DataMovementStatusResponse_Status_UNKNOWN_STATUS;
constexpr int DataMovementStatusResponse_Status_Status_ARRAYSIZE = DataMovementStatusResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataMovementStatusResponse_Status_descriptor();
template<typename T>
inline const std::string& DataMovementStatusResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMovementStatusResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMovementStatusResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataMovementStatusResponse_Status_descriptor(), enum_t_value);
}
inline bool DataMovementStatusResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMovementStatusResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataMovementStatusResponse_Status>(
    DataMovementStatusResponse_Status_descriptor(), name, value);
}
enum DataMovementDeleteResponse_Status : int {
  DataMovementDeleteResponse_Status_INVALID = 0,
  DataMovementDeleteResponse_Status_NOT_FOUND = 1,
  DataMovementDeleteResponse_Status_DELETED = 2,
  DataMovementDeleteResponse_Status_ACTIVE = 3,
  DataMovementDeleteResponse_Status_UNKNOWN = 4,
  DataMovementDeleteResponse_Status_DataMovementDeleteResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataMovementDeleteResponse_Status_DataMovementDeleteResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataMovementDeleteResponse_Status_IsValid(int value);
constexpr DataMovementDeleteResponse_Status DataMovementDeleteResponse_Status_Status_MIN = DataMovementDeleteResponse_Status_INVALID;
constexpr DataMovementDeleteResponse_Status DataMovementDeleteResponse_Status_Status_MAX = DataMovementDeleteResponse_Status_UNKNOWN;
constexpr int DataMovementDeleteResponse_Status_Status_ARRAYSIZE = DataMovementDeleteResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataMovementDeleteResponse_Status_descriptor();
template<typename T>
inline const std::string& DataMovementDeleteResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataMovementDeleteResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataMovementDeleteResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataMovementDeleteResponse_Status_descriptor(), enum_t_value);
}
inline bool DataMovementDeleteResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataMovementDeleteResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataMovementDeleteResponse_Status>(
    DataMovementDeleteResponse_Status_descriptor(), name, value);
}
// ===================================================================

class DataMovementCreateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementCreateRequest) */ {
 public:
  inline DataMovementCreateRequest() : DataMovementCreateRequest(nullptr) {}
  ~DataMovementCreateRequest() override;
  explicit constexpr DataMovementCreateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementCreateRequest(const DataMovementCreateRequest& from);
  DataMovementCreateRequest(DataMovementCreateRequest&& from) noexcept
    : DataMovementCreateRequest() {
    *this = ::std::move(from);
  }

  inline DataMovementCreateRequest& operator=(const DataMovementCreateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementCreateRequest& operator=(DataMovementCreateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementCreateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementCreateRequest* internal_default_instance() {
    return reinterpret_cast<const DataMovementCreateRequest*>(
               &_DataMovementCreateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataMovementCreateRequest& a, DataMovementCreateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementCreateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementCreateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementCreateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementCreateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementCreateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementCreateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementCreateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementCreateRequest";
  }
  protected:
  explicit DataMovementCreateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkflowFieldNumber = 3,
    kNamespaceFieldNumber = 4,
    kSourceFieldNumber = 5,
    kDestinationFieldNumber = 6,
    kDryrunFieldNumber = 7,
  };
  // string workflow = 3;
  void clear_workflow();
  const std::string& workflow() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow();
  PROTOBUF_NODISCARD std::string* release_workflow();
  void set_allocated_workflow(std::string* workflow);
  private:
  const std::string& _internal_workflow() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow(const std::string& value);
  std::string* _internal_mutable_workflow();
  public:

  // string namespace = 4;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // string source = 5;
  void clear_source();
  const std::string& source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string destination = 6;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // bool dryrun = 7;
  void clear_dryrun();
  bool dryrun() const;
  void set_dryrun(bool value);
  private:
  bool _internal_dryrun() const;
  void _internal_set_dryrun(bool value);
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementCreateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
  bool dryrun_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// -------------------------------------------------------------------

class DataMovementCreateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementCreateResponse) */ {
 public:
  inline DataMovementCreateResponse() : DataMovementCreateResponse(nullptr) {}
  ~DataMovementCreateResponse() override;
  explicit constexpr DataMovementCreateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementCreateResponse(const DataMovementCreateResponse& from);
  DataMovementCreateResponse(DataMovementCreateResponse&& from) noexcept
    : DataMovementCreateResponse() {
    *this = ::std::move(from);
  }

  inline DataMovementCreateResponse& operator=(const DataMovementCreateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementCreateResponse& operator=(DataMovementCreateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementCreateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementCreateResponse* internal_default_instance() {
    return reinterpret_cast<const DataMovementCreateResponse*>(
               &_DataMovementCreateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DataMovementCreateResponse& a, DataMovementCreateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementCreateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementCreateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementCreateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementCreateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementCreateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementCreateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementCreateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementCreateResponse";
  }
  protected:
  explicit DataMovementCreateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataMovementCreateResponse_Status Status;
  static constexpr Status CREATED =
    DataMovementCreateResponse_Status_CREATED;
  static constexpr Status FAILED =
    DataMovementCreateResponse_Status_FAILED;
  static inline bool Status_IsValid(int value) {
    return DataMovementCreateResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DataMovementCreateResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DataMovementCreateResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DataMovementCreateResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DataMovementCreateResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DataMovementCreateResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DataMovementCreateResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kMessageFieldNumber = 3,
    kStatusFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .datamovement.DataMovementCreateResponse.Status status = 2;
  void clear_status();
  ::datamovement::DataMovementCreateResponse_Status status() const;
  void set_status(::datamovement::DataMovementCreateResponse_Status value);
  private:
  ::datamovement::DataMovementCreateResponse_Status _internal_status() const;
  void _internal_set_status(::datamovement::DataMovementCreateResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementCreateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// -------------------------------------------------------------------

class DataMovementStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementStatusRequest) */ {
 public:
  inline DataMovementStatusRequest() : DataMovementStatusRequest(nullptr) {}
  ~DataMovementStatusRequest() override;
  explicit constexpr DataMovementStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementStatusRequest(const DataMovementStatusRequest& from);
  DataMovementStatusRequest(DataMovementStatusRequest&& from) noexcept
    : DataMovementStatusRequest() {
    *this = ::std::move(from);
  }

  inline DataMovementStatusRequest& operator=(const DataMovementStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementStatusRequest& operator=(DataMovementStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementStatusRequest* internal_default_instance() {
    return reinterpret_cast<const DataMovementStatusRequest*>(
               &_DataMovementStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DataMovementStatusRequest& a, DataMovementStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementStatusRequest";
  }
  protected:
  explicit DataMovementStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kMaxWaitTimeFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // int64 maxWaitTime = 2;
  void clear_maxwaittime();
  int64_t maxwaittime() const;
  void set_maxwaittime(int64_t value);
  private:
  int64_t _internal_maxwaittime() const;
  void _internal_set_maxwaittime(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  int64_t maxwaittime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// -------------------------------------------------------------------

class DataMovementStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementStatusResponse) */ {
 public:
  inline DataMovementStatusResponse() : DataMovementStatusResponse(nullptr) {}
  ~DataMovementStatusResponse() override;
  explicit constexpr DataMovementStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementStatusResponse(const DataMovementStatusResponse& from);
  DataMovementStatusResponse(DataMovementStatusResponse&& from) noexcept
    : DataMovementStatusResponse() {
    *this = ::std::move(from);
  }

  inline DataMovementStatusResponse& operator=(const DataMovementStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementStatusResponse& operator=(DataMovementStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementStatusResponse* internal_default_instance() {
    return reinterpret_cast<const DataMovementStatusResponse*>(
               &_DataMovementStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DataMovementStatusResponse& a, DataMovementStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementStatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementStatusResponse";
  }
  protected:
  explicit DataMovementStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataMovementStatusResponse_State State;
  static constexpr State PENDING =
    DataMovementStatusResponse_State_PENDING;
  static constexpr State STARTING =
    DataMovementStatusResponse_State_STARTING;
  static constexpr State RUNNING =
    DataMovementStatusResponse_State_RUNNING;
  static constexpr State COMPLETED =
    DataMovementStatusResponse_State_COMPLETED;
  static constexpr State UNKNOWN_STATE =
    DataMovementStatusResponse_State_UNKNOWN_STATE;
  static inline bool State_IsValid(int value) {
    return DataMovementStatusResponse_State_IsValid(value);
  }
  static constexpr State State_MIN =
    DataMovementStatusResponse_State_State_MIN;
  static constexpr State State_MAX =
    DataMovementStatusResponse_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    DataMovementStatusResponse_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return DataMovementStatusResponse_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return DataMovementStatusResponse_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return DataMovementStatusResponse_State_Parse(name, value);
  }

  typedef DataMovementStatusResponse_Status Status;
  static constexpr Status INVALID =
    DataMovementStatusResponse_Status_INVALID;
  static constexpr Status NOT_FOUND =
    DataMovementStatusResponse_Status_NOT_FOUND;
  static constexpr Status SUCCESS =
    DataMovementStatusResponse_Status_SUCCESS;
  static constexpr Status FAILED =
    DataMovementStatusResponse_Status_FAILED;
  static constexpr Status UNKNOWN_STATUS =
    DataMovementStatusResponse_Status_UNKNOWN_STATUS;
  static inline bool Status_IsValid(int value) {
    return DataMovementStatusResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DataMovementStatusResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DataMovementStatusResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DataMovementStatusResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DataMovementStatusResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DataMovementStatusResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DataMovementStatusResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kStateFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .datamovement.DataMovementStatusResponse.State state = 1;
  void clear_state();
  ::datamovement::DataMovementStatusResponse_State state() const;
  void set_state(::datamovement::DataMovementStatusResponse_State value);
  private:
  ::datamovement::DataMovementStatusResponse_State _internal_state() const;
  void _internal_set_state(::datamovement::DataMovementStatusResponse_State value);
  public:

  // .datamovement.DataMovementStatusResponse.Status status = 2;
  void clear_status();
  ::datamovement::DataMovementStatusResponse_Status status() const;
  void set_status(::datamovement::DataMovementStatusResponse_Status value);
  private:
  ::datamovement::DataMovementStatusResponse_Status _internal_status() const;
  void _internal_set_status(::datamovement::DataMovementStatusResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int state_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// -------------------------------------------------------------------

class DataMovementDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementDeleteRequest) */ {
 public:
  inline DataMovementDeleteRequest() : DataMovementDeleteRequest(nullptr) {}
  ~DataMovementDeleteRequest() override;
  explicit constexpr DataMovementDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementDeleteRequest(const DataMovementDeleteRequest& from);
  DataMovementDeleteRequest(DataMovementDeleteRequest&& from) noexcept
    : DataMovementDeleteRequest() {
    *this = ::std::move(from);
  }

  inline DataMovementDeleteRequest& operator=(const DataMovementDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementDeleteRequest& operator=(DataMovementDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DataMovementDeleteRequest*>(
               &_DataMovementDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DataMovementDeleteRequest& a, DataMovementDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementDeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementDeleteRequest";
  }
  protected:
  explicit DataMovementDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// -------------------------------------------------------------------

class DataMovementDeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementDeleteResponse) */ {
 public:
  inline DataMovementDeleteResponse() : DataMovementDeleteResponse(nullptr) {}
  ~DataMovementDeleteResponse() override;
  explicit constexpr DataMovementDeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementDeleteResponse(const DataMovementDeleteResponse& from);
  DataMovementDeleteResponse(DataMovementDeleteResponse&& from) noexcept
    : DataMovementDeleteResponse() {
    *this = ::std::move(from);
  }

  inline DataMovementDeleteResponse& operator=(const DataMovementDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementDeleteResponse& operator=(DataMovementDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const DataMovementDeleteResponse*>(
               &_DataMovementDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataMovementDeleteResponse& a, DataMovementDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementDeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementDeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementDeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementDeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementDeleteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementDeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementDeleteResponse";
  }
  protected:
  explicit DataMovementDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataMovementDeleteResponse_Status Status;
  static constexpr Status INVALID =
    DataMovementDeleteResponse_Status_INVALID;
  static constexpr Status NOT_FOUND =
    DataMovementDeleteResponse_Status_NOT_FOUND;
  static constexpr Status DELETED =
    DataMovementDeleteResponse_Status_DELETED;
  static constexpr Status ACTIVE =
    DataMovementDeleteResponse_Status_ACTIVE;
  static constexpr Status UNKNOWN =
    DataMovementDeleteResponse_Status_UNKNOWN;
  static inline bool Status_IsValid(int value) {
    return DataMovementDeleteResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DataMovementDeleteResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DataMovementDeleteResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DataMovementDeleteResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return DataMovementDeleteResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DataMovementDeleteResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DataMovementDeleteResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .datamovement.DataMovementDeleteResponse.Status status = 1;
  void clear_status();
  ::datamovement::DataMovementDeleteResponse_Status status() const;
  void set_status(::datamovement::DataMovementDeleteResponse_Status value);
  private:
  ::datamovement::DataMovementDeleteResponse_Status _internal_status() const;
  void _internal_set_status(::datamovement::DataMovementDeleteResponse_Status value);
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementDeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// -------------------------------------------------------------------

class DataMovementListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementListRequest) */ {
 public:
  inline DataMovementListRequest() : DataMovementListRequest(nullptr) {}
  ~DataMovementListRequest() override;
  explicit constexpr DataMovementListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementListRequest(const DataMovementListRequest& from);
  DataMovementListRequest(DataMovementListRequest&& from) noexcept
    : DataMovementListRequest() {
    *this = ::std::move(from);
  }

  inline DataMovementListRequest& operator=(const DataMovementListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementListRequest& operator=(DataMovementListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementListRequest* internal_default_instance() {
    return reinterpret_cast<const DataMovementListRequest*>(
               &_DataMovementListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataMovementListRequest& a, DataMovementListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementListRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementListRequest";
  }
  protected:
  explicit DataMovementListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkflowFieldNumber = 1,
    kNamespaceFieldNumber = 2,
  };
  // string workflow = 1;
  void clear_workflow();
  const std::string& workflow() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_workflow(ArgT0&& arg0, ArgT... args);
  std::string* mutable_workflow();
  PROTOBUF_NODISCARD std::string* release_workflow();
  void set_allocated_workflow(std::string* workflow);
  private:
  const std::string& _internal_workflow() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_workflow(const std::string& value);
  std::string* _internal_mutable_workflow();
  public:

  // string namespace = 2;
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr workflow_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// -------------------------------------------------------------------

class DataMovementListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:datamovement.DataMovementListResponse) */ {
 public:
  inline DataMovementListResponse() : DataMovementListResponse(nullptr) {}
  ~DataMovementListResponse() override;
  explicit constexpr DataMovementListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMovementListResponse(const DataMovementListResponse& from);
  DataMovementListResponse(DataMovementListResponse&& from) noexcept
    : DataMovementListResponse() {
    *this = ::std::move(from);
  }

  inline DataMovementListResponse& operator=(const DataMovementListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMovementListResponse& operator=(DataMovementListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMovementListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMovementListResponse* internal_default_instance() {
    return reinterpret_cast<const DataMovementListResponse*>(
               &_DataMovementListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DataMovementListResponse& a, DataMovementListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMovementListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMovementListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataMovementListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataMovementListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataMovementListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataMovementListResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMovementListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "datamovement.DataMovementListResponse";
  }
  protected:
  explicit DataMovementListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidsFieldNumber = 1,
  };
  // repeated string uids = 1;
  int uids_size() const;
  private:
  int _internal_uids_size() const;
  public:
  void clear_uids();
  const std::string& uids(int index) const;
  std::string* mutable_uids(int index);
  void set_uids(int index, const std::string& value);
  void set_uids(int index, std::string&& value);
  void set_uids(int index, const char* value);
  void set_uids(int index, const char* value, size_t size);
  std::string* add_uids();
  void add_uids(const std::string& value);
  void add_uids(std::string&& value);
  void add_uids(const char* value);
  void add_uids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& uids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_uids();
  private:
  const std::string& _internal_uids(int index) const;
  std::string* _internal_add_uids();
  public:

  // @@protoc_insertion_point(class_scope:datamovement.DataMovementListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> uids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_datamovement_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataMovementCreateRequest

// string workflow = 3;
inline void DataMovementCreateRequest::clear_workflow() {
  workflow_.ClearToEmpty();
}
inline const std::string& DataMovementCreateRequest::workflow() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateRequest.workflow)
  return _internal_workflow();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementCreateRequest::set_workflow(ArgT0&& arg0, ArgT... args) {
 
 workflow_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateRequest.workflow)
}
inline std::string* DataMovementCreateRequest::mutable_workflow() {
  std::string* _s = _internal_mutable_workflow();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementCreateRequest.workflow)
  return _s;
}
inline const std::string& DataMovementCreateRequest::_internal_workflow() const {
  return workflow_.Get();
}
inline void DataMovementCreateRequest::_internal_set_workflow(const std::string& value) {
  
  workflow_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::_internal_mutable_workflow() {
  
  return workflow_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::release_workflow() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementCreateRequest.workflow)
  return workflow_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementCreateRequest::set_allocated_workflow(std::string* workflow) {
  if (workflow != nullptr) {
    
  } else {
    
  }
  workflow_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workflow,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (workflow_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    workflow_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementCreateRequest.workflow)
}

// string namespace = 4;
inline void DataMovementCreateRequest::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& DataMovementCreateRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateRequest.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementCreateRequest::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateRequest.namespace)
}
inline std::string* DataMovementCreateRequest::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementCreateRequest.namespace)
  return _s;
}
inline const std::string& DataMovementCreateRequest::_internal_namespace_() const {
  return namespace__.Get();
}
inline void DataMovementCreateRequest::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::release_namespace_() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementCreateRequest.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementCreateRequest::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespace__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementCreateRequest.namespace)
}

// string source = 5;
inline void DataMovementCreateRequest::clear_source() {
  source_.ClearToEmpty();
}
inline const std::string& DataMovementCreateRequest::source() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateRequest.source)
  return _internal_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementCreateRequest::set_source(ArgT0&& arg0, ArgT... args) {
 
 source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateRequest.source)
}
inline std::string* DataMovementCreateRequest::mutable_source() {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementCreateRequest.source)
  return _s;
}
inline const std::string& DataMovementCreateRequest::_internal_source() const {
  return source_.Get();
}
inline void DataMovementCreateRequest::_internal_set_source(const std::string& value) {
  
  source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::_internal_mutable_source() {
  
  return source_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::release_source() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementCreateRequest.source)
  return source_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementCreateRequest::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (source_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementCreateRequest.source)
}

// string destination = 6;
inline void DataMovementCreateRequest::clear_destination() {
  destination_.ClearToEmpty();
}
inline const std::string& DataMovementCreateRequest::destination() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateRequest.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementCreateRequest::set_destination(ArgT0&& arg0, ArgT... args) {
 
 destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateRequest.destination)
}
inline std::string* DataMovementCreateRequest::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementCreateRequest.destination)
  return _s;
}
inline const std::string& DataMovementCreateRequest::_internal_destination() const {
  return destination_.Get();
}
inline void DataMovementCreateRequest::_internal_set_destination(const std::string& value) {
  
  destination_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::_internal_mutable_destination() {
  
  return destination_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementCreateRequest::release_destination() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementCreateRequest.destination)
  return destination_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementCreateRequest::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  destination_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (destination_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementCreateRequest.destination)
}

// bool dryrun = 7;
inline void DataMovementCreateRequest::clear_dryrun() {
  dryrun_ = false;
}
inline bool DataMovementCreateRequest::_internal_dryrun() const {
  return dryrun_;
}
inline bool DataMovementCreateRequest::dryrun() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateRequest.dryrun)
  return _internal_dryrun();
}
inline void DataMovementCreateRequest::_internal_set_dryrun(bool value) {
  
  dryrun_ = value;
}
inline void DataMovementCreateRequest::set_dryrun(bool value) {
  _internal_set_dryrun(value);
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateRequest.dryrun)
}

// -------------------------------------------------------------------

// DataMovementCreateResponse

// string uid = 1;
inline void DataMovementCreateResponse::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& DataMovementCreateResponse::uid() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateResponse.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementCreateResponse::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateResponse.uid)
}
inline std::string* DataMovementCreateResponse::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementCreateResponse.uid)
  return _s;
}
inline const std::string& DataMovementCreateResponse::_internal_uid() const {
  return uid_.Get();
}
inline void DataMovementCreateResponse::_internal_set_uid(const std::string& value) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementCreateResponse::_internal_mutable_uid() {
  
  return uid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementCreateResponse::release_uid() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementCreateResponse.uid)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementCreateResponse::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementCreateResponse.uid)
}

// .datamovement.DataMovementCreateResponse.Status status = 2;
inline void DataMovementCreateResponse::clear_status() {
  status_ = 0;
}
inline ::datamovement::DataMovementCreateResponse_Status DataMovementCreateResponse::_internal_status() const {
  return static_cast< ::datamovement::DataMovementCreateResponse_Status >(status_);
}
inline ::datamovement::DataMovementCreateResponse_Status DataMovementCreateResponse::status() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateResponse.status)
  return _internal_status();
}
inline void DataMovementCreateResponse::_internal_set_status(::datamovement::DataMovementCreateResponse_Status value) {
  
  status_ = value;
}
inline void DataMovementCreateResponse::set_status(::datamovement::DataMovementCreateResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateResponse.status)
}

// string message = 3;
inline void DataMovementCreateResponse::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& DataMovementCreateResponse::message() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementCreateResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementCreateResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementCreateResponse.message)
}
inline std::string* DataMovementCreateResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementCreateResponse.message)
  return _s;
}
inline const std::string& DataMovementCreateResponse::_internal_message() const {
  return message_.Get();
}
inline void DataMovementCreateResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementCreateResponse::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementCreateResponse::release_message() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementCreateResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementCreateResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementCreateResponse.message)
}

// -------------------------------------------------------------------

// DataMovementStatusRequest

// string uid = 1;
inline void DataMovementStatusRequest::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& DataMovementStatusRequest::uid() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementStatusRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementStatusRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementStatusRequest.uid)
}
inline std::string* DataMovementStatusRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementStatusRequest.uid)
  return _s;
}
inline const std::string& DataMovementStatusRequest::_internal_uid() const {
  return uid_.Get();
}
inline void DataMovementStatusRequest::_internal_set_uid(const std::string& value) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementStatusRequest::_internal_mutable_uid() {
  
  return uid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementStatusRequest::release_uid() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementStatusRequest.uid)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementStatusRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementStatusRequest.uid)
}

// int64 maxWaitTime = 2;
inline void DataMovementStatusRequest::clear_maxwaittime() {
  maxwaittime_ = int64_t{0};
}
inline int64_t DataMovementStatusRequest::_internal_maxwaittime() const {
  return maxwaittime_;
}
inline int64_t DataMovementStatusRequest::maxwaittime() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementStatusRequest.maxWaitTime)
  return _internal_maxwaittime();
}
inline void DataMovementStatusRequest::_internal_set_maxwaittime(int64_t value) {
  
  maxwaittime_ = value;
}
inline void DataMovementStatusRequest::set_maxwaittime(int64_t value) {
  _internal_set_maxwaittime(value);
  // @@protoc_insertion_point(field_set:datamovement.DataMovementStatusRequest.maxWaitTime)
}

// -------------------------------------------------------------------

// DataMovementStatusResponse

// .datamovement.DataMovementStatusResponse.State state = 1;
inline void DataMovementStatusResponse::clear_state() {
  state_ = 0;
}
inline ::datamovement::DataMovementStatusResponse_State DataMovementStatusResponse::_internal_state() const {
  return static_cast< ::datamovement::DataMovementStatusResponse_State >(state_);
}
inline ::datamovement::DataMovementStatusResponse_State DataMovementStatusResponse::state() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementStatusResponse.state)
  return _internal_state();
}
inline void DataMovementStatusResponse::_internal_set_state(::datamovement::DataMovementStatusResponse_State value) {
  
  state_ = value;
}
inline void DataMovementStatusResponse::set_state(::datamovement::DataMovementStatusResponse_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:datamovement.DataMovementStatusResponse.state)
}

// .datamovement.DataMovementStatusResponse.Status status = 2;
inline void DataMovementStatusResponse::clear_status() {
  status_ = 0;
}
inline ::datamovement::DataMovementStatusResponse_Status DataMovementStatusResponse::_internal_status() const {
  return static_cast< ::datamovement::DataMovementStatusResponse_Status >(status_);
}
inline ::datamovement::DataMovementStatusResponse_Status DataMovementStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementStatusResponse.status)
  return _internal_status();
}
inline void DataMovementStatusResponse::_internal_set_status(::datamovement::DataMovementStatusResponse_Status value) {
  
  status_ = value;
}
inline void DataMovementStatusResponse::set_status(::datamovement::DataMovementStatusResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:datamovement.DataMovementStatusResponse.status)
}

// string message = 3;
inline void DataMovementStatusResponse::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& DataMovementStatusResponse::message() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementStatusResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementStatusResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementStatusResponse.message)
}
inline std::string* DataMovementStatusResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementStatusResponse.message)
  return _s;
}
inline const std::string& DataMovementStatusResponse::_internal_message() const {
  return message_.Get();
}
inline void DataMovementStatusResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementStatusResponse::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementStatusResponse::release_message() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementStatusResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementStatusResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementStatusResponse.message)
}

// -------------------------------------------------------------------

// DataMovementDeleteRequest

// string uid = 1;
inline void DataMovementDeleteRequest::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& DataMovementDeleteRequest::uid() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementDeleteRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementDeleteRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementDeleteRequest.uid)
}
inline std::string* DataMovementDeleteRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementDeleteRequest.uid)
  return _s;
}
inline const std::string& DataMovementDeleteRequest::_internal_uid() const {
  return uid_.Get();
}
inline void DataMovementDeleteRequest::_internal_set_uid(const std::string& value) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementDeleteRequest::_internal_mutable_uid() {
  
  return uid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementDeleteRequest::release_uid() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementDeleteRequest.uid)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementDeleteRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementDeleteRequest.uid)
}

// -------------------------------------------------------------------

// DataMovementDeleteResponse

// .datamovement.DataMovementDeleteResponse.Status status = 1;
inline void DataMovementDeleteResponse::clear_status() {
  status_ = 0;
}
inline ::datamovement::DataMovementDeleteResponse_Status DataMovementDeleteResponse::_internal_status() const {
  return static_cast< ::datamovement::DataMovementDeleteResponse_Status >(status_);
}
inline ::datamovement::DataMovementDeleteResponse_Status DataMovementDeleteResponse::status() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementDeleteResponse.status)
  return _internal_status();
}
inline void DataMovementDeleteResponse::_internal_set_status(::datamovement::DataMovementDeleteResponse_Status value) {
  
  status_ = value;
}
inline void DataMovementDeleteResponse::set_status(::datamovement::DataMovementDeleteResponse_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:datamovement.DataMovementDeleteResponse.status)
}

// -------------------------------------------------------------------

// DataMovementListRequest

// string workflow = 1;
inline void DataMovementListRequest::clear_workflow() {
  workflow_.ClearToEmpty();
}
inline const std::string& DataMovementListRequest::workflow() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementListRequest.workflow)
  return _internal_workflow();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementListRequest::set_workflow(ArgT0&& arg0, ArgT... args) {
 
 workflow_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementListRequest.workflow)
}
inline std::string* DataMovementListRequest::mutable_workflow() {
  std::string* _s = _internal_mutable_workflow();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementListRequest.workflow)
  return _s;
}
inline const std::string& DataMovementListRequest::_internal_workflow() const {
  return workflow_.Get();
}
inline void DataMovementListRequest::_internal_set_workflow(const std::string& value) {
  
  workflow_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementListRequest::_internal_mutable_workflow() {
  
  return workflow_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementListRequest::release_workflow() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementListRequest.workflow)
  return workflow_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementListRequest::set_allocated_workflow(std::string* workflow) {
  if (workflow != nullptr) {
    
  } else {
    
  }
  workflow_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), workflow,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (workflow_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    workflow_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementListRequest.workflow)
}

// string namespace = 2;
inline void DataMovementListRequest::clear_namespace_() {
  namespace__.ClearToEmpty();
}
inline const std::string& DataMovementListRequest::namespace_() const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementListRequest.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMovementListRequest::set_namespace_(ArgT0&& arg0, ArgT... args) {
 
 namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:datamovement.DataMovementListRequest.namespace)
}
inline std::string* DataMovementListRequest::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementListRequest.namespace)
  return _s;
}
inline const std::string& DataMovementListRequest::_internal_namespace_() const {
  return namespace__.Get();
}
inline void DataMovementListRequest::_internal_set_namespace_(const std::string& value) {
  
  namespace__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataMovementListRequest::_internal_mutable_namespace_() {
  
  return namespace__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataMovementListRequest::release_namespace_() {
  // @@protoc_insertion_point(field_release:datamovement.DataMovementListRequest.namespace)
  return namespace__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataMovementListRequest::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    
  } else {
    
  }
  namespace__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (namespace__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    namespace__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:datamovement.DataMovementListRequest.namespace)
}

// -------------------------------------------------------------------

// DataMovementListResponse

// repeated string uids = 1;
inline int DataMovementListResponse::_internal_uids_size() const {
  return uids_.size();
}
inline int DataMovementListResponse::uids_size() const {
  return _internal_uids_size();
}
inline void DataMovementListResponse::clear_uids() {
  uids_.Clear();
}
inline std::string* DataMovementListResponse::add_uids() {
  std::string* _s = _internal_add_uids();
  // @@protoc_insertion_point(field_add_mutable:datamovement.DataMovementListResponse.uids)
  return _s;
}
inline const std::string& DataMovementListResponse::_internal_uids(int index) const {
  return uids_.Get(index);
}
inline const std::string& DataMovementListResponse::uids(int index) const {
  // @@protoc_insertion_point(field_get:datamovement.DataMovementListResponse.uids)
  return _internal_uids(index);
}
inline std::string* DataMovementListResponse::mutable_uids(int index) {
  // @@protoc_insertion_point(field_mutable:datamovement.DataMovementListResponse.uids)
  return uids_.Mutable(index);
}
inline void DataMovementListResponse::set_uids(int index, const std::string& value) {
  uids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:datamovement.DataMovementListResponse.uids)
}
inline void DataMovementListResponse::set_uids(int index, std::string&& value) {
  uids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:datamovement.DataMovementListResponse.uids)
}
inline void DataMovementListResponse::set_uids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:datamovement.DataMovementListResponse.uids)
}
inline void DataMovementListResponse::set_uids(int index, const char* value, size_t size) {
  uids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:datamovement.DataMovementListResponse.uids)
}
inline std::string* DataMovementListResponse::_internal_add_uids() {
  return uids_.Add();
}
inline void DataMovementListResponse::add_uids(const std::string& value) {
  uids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:datamovement.DataMovementListResponse.uids)
}
inline void DataMovementListResponse::add_uids(std::string&& value) {
  uids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:datamovement.DataMovementListResponse.uids)
}
inline void DataMovementListResponse::add_uids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  uids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:datamovement.DataMovementListResponse.uids)
}
inline void DataMovementListResponse::add_uids(const char* value, size_t size) {
  uids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:datamovement.DataMovementListResponse.uids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DataMovementListResponse::uids() const {
  // @@protoc_insertion_point(field_list:datamovement.DataMovementListResponse.uids)
  return uids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DataMovementListResponse::mutable_uids() {
  // @@protoc_insertion_point(field_mutable_list:datamovement.DataMovementListResponse.uids)
  return &uids_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace datamovement

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::datamovement::DataMovementCreateResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::datamovement::DataMovementCreateResponse_Status>() {
  return ::datamovement::DataMovementCreateResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::datamovement::DataMovementStatusResponse_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::datamovement::DataMovementStatusResponse_State>() {
  return ::datamovement::DataMovementStatusResponse_State_descriptor();
}
template <> struct is_proto_enum< ::datamovement::DataMovementStatusResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::datamovement::DataMovementStatusResponse_Status>() {
  return ::datamovement::DataMovementStatusResponse_Status_descriptor();
}
template <> struct is_proto_enum< ::datamovement::DataMovementDeleteResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::datamovement::DataMovementDeleteResponse_Status>() {
  return ::datamovement::DataMovementDeleteResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_datamovement_2eproto
