The copy-offload server is implemented as an "User Container". This doc
assumes the reader is familiar with the "NNF User Containers" feature and with
data movement profiles as documented in "Data Movement Overview".

The copy-offload server is managed by a custom NnfContainerProfile named
`copy-offload-default`. This profile must be named as the `profile` in the
"#DW container" directive of the user's Workflow resource. If a user requires a
different `Storages` definition than the one provided in that profile then a
new profile should be created from it.

Find more info about the NnfContainerProfile in the "NNF User Containers" doc.

The copy-offload server uses a custom NnfDataMovementProfile named (also)
`copy-offload-default` which defines the copy commands it will use. This
profile will be specified in the copy-offload request made by the user's.

Find more info about the NnfDataMovementProfile in the "Data Movement Overview"
doc.


== Authentication configuration

The copy-offload service requires a self-signed TLS certificate and key, and
the client requires a JWT signed by that key. These will be created in k8s
`Secret` resources.

The following tool will read the `SystemConfiguration/default` resource from
the cluster and will create two new `Secret` resources. The first Secret is for
the copy-offload server and it will hold a self-signed TLS certificate and key.
The second Secret is for the clients and it will hold the above TLS certificate
and a JWT (JSON Web Token) signed with the key. The content of this second
Secret must be copied to each compute node.

From the nnf-deploy workarea run the tool to generate the secrets:

```console
cd nnf-dm 
./tools/mk-copy-offload-secrets.sh
```

Confirm that the `nnf-dm-copy-offload-client` and `nnf-dm-copy-offload-server`
secrets have been created:

```console
kubectl get secrets
```

```bash
NAME                         TYPE                                  DATA   AGE
nnf-dm-copy-offload          kubernetes.io/service-account-token   3      67m
nnf-dm-copy-offload-client   Opaque                                2      67m
nnf-dm-copy-offload-server   kubernetes.io/tls                     2      67m
```

(The `nnf-dm-copy-offload` secret is used by the copy-offload server pods when
talking to the k8s API server and was created when nnf-dm was deployed.)

== Client Authentication

The TLS certificate and token from the `nnf-dm-copy-offload-client` Secret
must be installed on each compute node. These will be used by the
libcopyoffload library when it sends messages to the copy-offload server.

The certificate will be installed as `/etc/copy-offload/cert.pem` and the
token will be installed as `/etc/copy-offload/token.der`.

=== Install client auth via nnf-deploy tool

If `nnf-deploy install` is being used to install NNF components onto the
compute nodes, then it will fetch the client TLS certificate and token from the
`nnf-dm-copy-offload-client` Secret and install them on each compute.

=== Install client auth manually

Fetch the TLS certificate and token from the `nnf-dm-copy-offload-client`
Secret:

```console
SECRET=nnf-dm-copy-offload-client
NAMESPACE=default

kubectl get secret $SECRET -n $NAMESPACE -o json | jq -Mr '.data.token' | base64 --decode > ./token.der
kubectl get secret $SECRET -n $NAMESPACE -o json | jq -Mr '.data["tls.crt"]' | base64 --decode > ./cert.pem
```

Install those files on each compute in `/etc/copy-offload/`.

== Testing in KIND

Testing the copy-offload service in a KIND environment means being in a
limited environment with certain pieces mocked.  The KIND environment created
by the tools in nnf-deploy mounts the local host's `/tmp/nnf` directory into
each KIND container as `/mnt/nnf`. This `/tmp/nnf` directory will be used to
move things from the local host into the KIND containers.

=== Test tool for libcopyoffload

Begin by building a version of the libcopyoffload `tester` tool that will
run in the KIND containers. This tool links the libcopyoffload library and
can be used to exercise the library. The executable will land in
`./crossbin/tester`:

```console
cd nnf-dm
make build-copy-offload-tester-cross
```

Copy the `tester` executable into the `/tmp/nnf` to make it visible inside
the KIND containers:

```console
cp crossbin/tester /tmp/nnf
```

Confirm that it will run inside the KIND container, recalling that the path is
`/mnt/nnf/` when inside the container:

``console
docker exec kind-worker3 /mnt/nnf/tester -h
```

=== Authentication for test tool

The libcopyoffload library requires the TLS certificate and token that you
obtained from the "Install client auth manually" section above. Copy those
`token.der` and `cert.pem` files to `/tmp/nnf`:


```console
cp cert.pem token.der /tmp/nnf
```

Confirm that the files are visible inside a KIND container:

```console
docker exec kind-worker3 /bin/ls /mnt/nnf/cert.pem /mnt/nnf/token.der
```

=== Update /etc/hosts

Add "rabbit" ip/host names to the /etc/hosts on the client (pretend compute)
node. These are the names in the SAN portion of the TLS certificate.

docker exec kind-worker3 bash -c "echo '172.18.0.2 kind-worker2' | tee -a /etc/hosts"

=== Build nnf-dm-copy-offload for Mac

Build a version of the nnf-dm-copy-offload container for use on the Mac:

```console
cd nnf-dm
make build-copy-offload-docker-local
make kind-push-copy-offload
```

=== Create a dummy global lustre filesystem

Apply the following resource to create a dummy Lustre filesystem resource
for the KIND environment:

```console
kubectl apply -f - <<EOF
apiVersion: lus.cray.hpe.com/v1beta1
kind: LustreFileSystem
metadata:
  name: foo
  namespace: default
spec:
  name: foo
  mgsNids: 172.31.241.111@tcp
  mountRoot: /lus/foo
  namespaces:
    default:
      modes:
      - ReadWriteMany
EOF
```

=== Create a workflow that uses the copy-offload service

Apply the following workflow which references the copy-offload service.

The "#DW container" directive refences the "copy-offload-default" container
profile described earlier. That container profile runs the copy-offload
service as a pod. It also references the `/lus/foo` dummy Lustre filesystem we
created earlier. The container profile contains definitions for the
`DW_JOB_my_storage` and `DW_GLOBAL_lus` variables used in this directive.

See "User Interactions" "container" for an explanation of the `container`
directive.

```console
kubectl apply -f - <<EOF
apiVersion: dataworkflowservices.github.io/v1alpha2
kind: Workflow
metadata:
  name: copy-offload-yellow
  namespace: default
spec:
  desiredState: "Proposal"
  dwDirectives:
    - "#DW jobdw name=copyoff-gfs2 type=gfs2 capacity=50GB"
    - "#DW container name=copyoff-container profile=copy-offload-default \
      DW_JOB_my_storage=copyoff-gfs2 DW_GLOBAL_lus=/lus/foo/copyoff"
  wlmID: "Bubbly WLM"
  jobID: "fDeansJob3"
  userID: 1050
  groupID: 1051
EOF
```

Progress that workflow through its states until it reaches `PreRun`, filling in
the `Servers` and `Computes` as appropriate.

At this point the copy-offload server pod can be found on the rabbit in the
`default` namespace:

```console
kubectl get pods -n default -o wide
```

=== Try curl

: dean-mbp; docker exec -it kind-worker3 bash
root@kind-worker3:/# TOKEN=$(</mnt/nnf/token.der)
root@kind-worker3:/# curl -H 'Accepts-version: 1.0' -H "Authorization: Bearer $TOKEN" --cacert /mnt/nnf/cert.pem https://kind-worker2:5000/hello

=== Try tester

docker exec kind-worker3 /mnt/nnf/tester -t /mnt/nnf/token.der -x /mnt/nnf/cert.pem -v -l kind-worker2:5000

docker exec kind-worker3 /mnt/nnf/tester -t /mnt/nnf/token.der -x /mnt/nnf/cert.pem -o -C kind-worker3 -S /mnt/nnf/no-source -D /lus/no-dest -W no-such-workflow -v kind-worker2:5000





curl -v -X POST -d @offload-req.yaml localhost:8080/trial


